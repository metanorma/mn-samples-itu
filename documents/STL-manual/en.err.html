<html><head><title>/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.err.html errors</title>
<meta charset="UTF-8"/>
<style> pre { white-space: pre-wrap; }
thead th { font-weight: bold; background-color: aqua; }
.severity0 { font-weight: bold; background-color: lightpink }
.severity1 { font-weight: bold; }
.severity2 { }
.severity3 { font-style: italic; color: grey; }
</style>
</head><body><h1>/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.err.html errors</h1>
<ul><li><p><b><a href="#Relaton">Relaton</a></b>: Severity 3: <b>17</b> errors</p></li>

<li><p><b><a href="#Style">Style</a></b>: Severity 2: <b>58</b> errors</p></li>

<li><p><b><a href="#Metanorma_XML_Syntax">Metanorma XML Syntax</a></b>: Severity 2: <b>1</b> errors</p></li>
</ul>
<h2 id="Relaton">Relaton</h2>
<table border="1">
<thead><th width="5%">Line</th><th width="20%">ID</th>
<th width="30%">Message</th><th width="40%">Context</th><th width="5%">Severity</th></thead>
<tbody>
<tr class="severity3">
<td></td><th><code>--</code></th>
<td>Downloaded index from <code>https://​raw.​githubusercontent.com/​relaton/​relaton-data-itu-r/main/​index-v1.zip</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>--</code></th>
<td>Downloaded index from <code>https://​raw.​githubusercontent.com/​relaton/​relaton-data-rfcs/​main/index-v1.zip</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>IETF RFC 3551</code></th>
<td>Found: <code>RFC 3551</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-R BS.1534-1</code></th>
<td>Not found.</td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.111</code></th>
<td>Found: <code>ITU-T G.111 (11/​1988)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.191</code></th>
<td>Found: <code>ITU-T G.191 (05/​2024)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.725</code></th>
<td>Found: <code>ITU-T G.725 (11/​1988)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.726 Annex A</code></th>
<td>Found: <code>ITU-T G.726 Annex A (11/​1994)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.727 Annex A</code></th>
<td>Found: <code>ITU-T G.727 Annex A (11/​1994)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.728 Annex G</code></th>
<td>Found: <code>ITU-T G.728 Annex G (11/​1994)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T G.728 Annex I</code></th>
<td>Found: <code>ITU-T G.728 Annex I (05/​1999)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T P.11</code></th>
<td>Found: <code>ITU-T P.11 (11/​1988)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T P.50 Annex I</code></th>
<td>Not found.</td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T P.56 (1989)</code></th>
<td>Not found.</td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T P.56 (1989)</code></th>
<td>There was no match for <code>1989</code> year, though there were matches found for <code>2011</code>, <code>2011</code>, <code>1993</code>, <code>1988</code>, <code>1987</code> years.</td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T P.800</code></th>
<td>Found: <code>ITU-T P.800 (08/​1996)</code></td><td><pre></pre></td><td>3</td></tr>
<tr class="severity3">
<td></td><th><code>ITU-T P.830</code></th>
<td>Found: <code>ITU-T P.830 (02/​1996)</code></td><td><pre></pre></td><td>3</td></tr>
</tbody></table>
<h2 id="Style">Style</h2>
<table border="1">
<thead><th width="5%">Line</th><th width="20%">ID</th>
<th width="30%">Message</th><th width="40%">Context</th><th width="5%">Severity</th></thead>
<tbody>
<tr class="severity2">
<td></td><th><code>--</code></th>
<td>ITU-T G.191 STL-2019 Manual does not match ITU document identifier conventions</td><td><pre></pre></td><td>2</td></tr>
<tr class="severity2">
<td></td><th><code>--</code></th>
<td>No Keywords have been provided</td><td><pre></pre></td><td>2</td></tr>
<tr class="severity2">
<td></td><th><code>--</code></th>
<td>No Summary has been provided</td><td><pre></pre></td><td>2</td></tr>
<tr class="severity2">
<td>000022</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_b5ff7f95-f781-a42e-99b6-87a561430419'>_b5ff7f95-f781-a42e-99b6-87a561430419</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_b5ff7f95-f781-a42e-99b6-87a561430419&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;FOREWORD&lt;/title&gt;
&lt;p id=&quot;_e39b916a-1911-02cf-fce1-6e2bbef3a82b&quot;&gt;The International Telecommunication Union (ITU) is the United Nations specialized agency in the field of telecommunications , information and communication technologies (ICTs). The ITU Telecommunication Standardization Sector (ITU-T) is a permanent organ of ITU. ITU-T is responsible for studying technical, operating and tariff questions and issuing Recommendations on them with a view to standardizing telecommunications on a worldwide basis.&lt;/p&gt;

&lt;p id=&quot;_06f59af6-f0ab-5af2-fd46-4e11f29b088c&quot;&gt;The World Telecommunication Standardization Assembly (WTSA), which meets every four years, establishes the topics for study by the ITU T study groups which, in turn, produce Recommendations on these topics.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000035</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_introduction'>_​introduction</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;introduction id=&quot;_introduction&quot; obligation=&quot;informative&quot;&gt;
&lt;title&gt;Introduction&lt;/title&gt;
&lt;p id=&quot;_939e976c-b3bf-142c-c432-144ccebcd3e3&quot;&gt;In July 1990, Study Group XV of the then CCITT (Comité Consultatif International Téléphonique et Télégraphique) decided to set up a group to deal with the development of common software tools to help in the development of speech coding standards. In the same period, cooperation was requested with SG XII Speech Quality Experts Group (SQEG), and a group called &apos;User&apos;s Group on Software Tools&apos; (UGST) was initially established with almost 20 corresponding members. The basic means of interaction were the then incipient electronic mail (e-mail) messages, for the exchange of files and experiences — UGST was actually one of the pioneer groups in ITU collaborating via electronic means. In addition to this, there were meetings held mainly during regular Working Party XV/2 (Signal Processing) sessions, where most of the decisions were made.&lt;/p&gt;

&lt;p id=&quot;_85d1a658-9f20-16e9-190b-3f08cc7f24df&quot;&gt;As result of that very intensive work, several software tools evolved forming the &apos;&lt;em&gt;1992 ITU-T Software Tool Library&lt;/em&gt;&apos; (STL92) which included, as its first application, the Qualification Test for a Speech Coder at 8 kbit/s. After this initial release, another release was approved by ITU-T Study Group 15 in May, 1996, and called STL96. The STL96 introduced substantive improvement and new features to the STL92. In November 2000, ITU-T Study Group 16 approved an updated version to the STL, the STL2000. In 2005, another updated version of the STL, STL2005, was accepted.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000272</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_definition_of_terms'>_​definition_of_​terms</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_definition_of_terms&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Definition of terms&lt;/title&gt;
&lt;p id=&quot;_5f058b4a-9162-c689-07da-1e867b877fa1&quot;&gt;In the documentation of the ITU-T software tools, several terms are widely used and are defined below.&lt;/p&gt;

&lt;clause id=&quot;ovl-point&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000386</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_8be8a88c-b21d-3cf2-1fda-ab83b91905f1'>_8be8a88c-b21d-3cf2-1fda-ab83b91905f1</a></code></th>
<td>There is an instance of table nested within example</td><td><pre>&lt;table id=&quot;_8be8a88c-b21d-3cf2-1fda-ab83b91905f1&quot;&gt;
&lt;name&gt;Left-justified data&lt;/name&gt;
&lt;thead&gt; &lt;tr&gt; &lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt; &lt;em&gt;Bit number&lt;/em&gt; &lt;/th&gt;
&lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt;15&lt;/th&gt;
&lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt;14&lt;/th&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000426</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_9cdbf5da-3536-30cc-879f-cc88bee0b578'>_9cdbf5da-3536-30cc-879f-cc88bee0b578</a></code></th>
<td>There is an instance of table nested within example</td><td><pre>&lt;table id=&quot;_9cdbf5da-3536-30cc-879f-cc88bee0b578&quot;&gt;
&lt;name&gt;Right-justified, sign-extended data&lt;/name&gt;
&lt;thead&gt; &lt;tr&gt; &lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt; &lt;em&gt;Bit number&lt;/em&gt; &lt;/th&gt;
&lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt;15&lt;/th&gt;
&lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt;14&lt;/th&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000466</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_7b987637-fb12-127f-a7c2-2f8d3e64ec48'>_7b987637-fb12-127f-a7c2-2f8d3e64ec48</a></code></th>
<td>There is an instance of table nested within example</td><td><pre>&lt;table id=&quot;_7b987637-fb12-127f-a7c2-2f8d3e64ec48&quot;&gt;
&lt;name&gt;Right-justified, unsigned data&lt;/name&gt;
&lt;thead&gt; &lt;tr&gt; &lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt; &lt;em&gt;Bit number&lt;/em&gt; &lt;/th&gt;
&lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt;15&lt;/th&gt;
&lt;th valign=&quot;middle&quot; align=&quot;center&quot;&gt;14&lt;/th&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000796</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_g_711_the_itu_t_64_kbits_log_pcm_algorithm'>_g_711_​the_itu_t_64_​kbits_log_​pcm_​algorithm</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_g_711_the_itu_t_64_kbits_log_pcm_algorithm&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;G.711: The ITU-T 64 kbit/s log-PCM algorithm&lt;/title&gt;
&lt;p id=&quot;_ba238f30-23b8-b6d1-55de-51c07a32dbb9&quot;&gt;In the early 1960&apos;s an interest was expressed in encoding the analog signals in telephone networks, mainly to reduce costs in switching and multiplexing equipments and to allow the integration of communication and computing, increasing the efficiency in operation and maintenance &lt;eref type=&quot;inline&quot; bibitemid=&quot;Qual-meas-tel-sys&quot; citeas=&quot;[51]&quot;/&gt;.&lt;/p&gt;

&lt;p id=&quot;_84305471-0794-da8f-4e39-9705b5e9fa16&quot;&gt;In 1972, the then CCITT published the Recommendation ITU-T G.711 that constitutes the principal reference as far as transmission systems are concerned &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.711&quot; citeas=&quot;[4]&quot;/&gt;. The basic principle of the algorithm is to code speech using 8 bits per sample, the input voiceband signal being sampled at 8 kHz, keeping the telephony bandwidth of 300—​3400 Hz. With this combination, each voice channel requires 64 kbit/s.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>000846</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation'>_​implementation</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_39ee13de-8169-fb5b-52ea-817d78a63f6f&quot;&gt;This implementation of the G.711 can be found in the module &lt;tt&gt;g711.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;g711.h&lt;/tt&gt;.&lt;/p&gt;

&lt;p id=&quot;_c1457c55-28a5-04cc-b591-98d62935a880&quot;&gt;For the reason explained before, an algorithmic approach to the G.711 was followed. For the compression routines, first the samples are converted from two&apos;s complement to signed magnitude notation&lt;fn reference=&quot;5&quot;&gt; &lt;p id=&quot;_a3ceae1a-0f95-f7e6-c3e5-f66764fc4fc6&quot;&gt;Using the samples as two&apos;s complement in the compression algorithm is a very common error whose effects are only noticeable for small amplitude signals. Our approach agrees to the one in G.726 &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.726&quot; citeas=&quot;[8]&quot;/&gt;, block &lt;em&gt;compress&lt;/em&gt;.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001038</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_plc_algorithm_implementation'>_plc_​algorithm_​implementation</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_plc_algorithm_implementation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;PLC Algorithm Implementation&lt;/title&gt;
&lt;p id=&quot;_f76da578-03f0-1292-9c32-a24e7aca7db6&quot;&gt;A detailed line by line description of the C++ code can be found in section I.3 &quot;Algorithm description with annotated C++ code&quot; of G.711 Appendix I &lt;eref type=&quot;inline&quot; bibitemid=&quot;G711-appendix-I&quot; citeas=&quot;[82]&quot;/&gt; and will not be repeated here. The public interface functions that are called by applications are covered. The C++ version is in the &lt;tt&gt;g711iplc\cpp_code&lt;/tt&gt; directory (files &lt;tt&gt;lowcfe.h&lt;/tt&gt; and lowcfe.cc). The ANSI C version, contained in the files &lt;tt&gt;lowcfe.h&lt;/tt&gt; and &lt;tt&gt;lowcfe.c&lt;/tt&gt;, is a translation of the C++ code to C. The interface functions are the same for both versions, with the exception that the C versions of the routines take an extra argument for the data structure that is implicitly passed to C++ member functions in the class instance data. As for other STL modules, only the ANSI C version is compiled during STL2005 building.&lt;/p&gt;

&lt;clause id=&quot;_constructor&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001259</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_g_726_the_itu_t_adpcm_algorithm_at_40_32_24_and_16_kbits'>_g_726_​the_itu_t_​adpcm_​algorithm_at_40_​32_24_and_​16_kbits</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_g_726_the_itu_t_adpcm_algorithm_at_40_32_24_and_16_kbits&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;G.726: The ITU-T ADPCM algorithm at 40, 32, 24, and 16 kbit/s&lt;/title&gt;
&lt;p id=&quot;_7729c708-35be-a9c5-5fe9-1f722c158e49&quot;&gt;In 1982, a group was established by the then CCITT Study Group XVIII to study the standardization of a speech coding technique that could reduce the 64 kbit/s rate used in digital links, as per Recommendation ITU-T G.711 (see related Chapter), by half while maintaining the same voice quality.&lt;/p&gt;

&lt;p id=&quot;_bd30e4ea-d584-26dd-7e02-f39c50289e1c&quot;&gt;After considering contributions received from several organizations, there was a general feeling that the ADPCM &lt;em&gt;(Adaptive Differential Pulse Code Modulation)&lt;/em&gt; technique could provide a good quality coder. This process of finalizing an algorithm took 18 months of development and objective and subjective testings, to culminate in an ITU Recommendation, published in October, 1984, and available in the Red Book series as Recommendation ITU-T G.721.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001273</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_32_kbits_adpcm'>_​description_of_the_​32_kbits_​adpcm</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_32_kbits_adpcm&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the 32 kbit/s ADPCM&lt;/title&gt;
&lt;p id=&quot;_40a2305f-986f-8c5d-2f05-fda4167fcbea&quot;&gt;The basic idea behind the G.721 coder is to code into 4-bit samples the input speech-band signals, sampled at 8 kHz and represented by the 8-bit of G.711 A or &lt;asciimath&gt;mu&lt;/asciimath&gt; law samples. The decoder just implements the reverse procedure.&lt;/p&gt;

&lt;p id=&quot;_f43c2aef-8570-4e5e-546a-6c1a3a80671e&quot;&gt;The ADPCM algorithm of the G.721 exploits the predictability of the speech signals. Therefore, an adaptive predictor is used to compute the difference signal &lt;asciimath&gt;d(k)&lt;/asciimath&gt; (based on the expanded input log-pcm sample &lt;asciimath&gt;s(k)&lt;/asciimath&gt;), which is then quantized by an adaptive quantizer using 4 bits. These bits are sent to the decoder and then fed into an inverse quantizer. The difference signal is used to calculate the reconstructed signal, &lt;asciimath&gt;s_r(k)&lt;/asciimath&gt;, which is compressed (A- or &lt;asciimath&gt;mu&lt;/asciimath&gt;-law) and output from the decoder (&lt;asciimath&gt;s_d(k)&lt;/asciimath&gt;).&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001378</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_itu_t_stl_g_726_implementation'>_itu_t_​stl_g_726_​implementation</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_itu_t_stl_g_726_implementation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;ITU-T STL G.726 Implementation&lt;/title&gt;
&lt;p id=&quot;_8538f83e-0ae7-a2b9-bd52-c95635a86efe&quot;&gt;The STL implementation of the G.726 algorithm can be found in module &lt;tt&gt;g726.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;g726.h&lt;/tt&gt;.&lt;/p&gt;

&lt;p id=&quot;_e6b1f522-e0a0-c0d6-cbec-cf299150fc95&quot;&gt;Originally in Fortran (VAX Fortran-77), the source was translated by means of the public-domain code converter &lt;em&gt;f2c&lt;/em&gt; &lt;eref type=&quot;inline&quot; bibitemid=&quot;f2c&quot; citeas=&quot;[27]&quot;/&gt;. This explain why the code makes extensive use of passage of parameters by reference, rather than by value, and why many functions, that could be implemented as macros (using the C pre-processor directive &lt;tt&gt;#define&lt;/tt&gt;), are routines, and as well as all routines return &lt;tt&gt;void&lt;/tt&gt;.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001661</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_embedded_adpcm'>_​description_of_the_​embedded_​adpcm</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_embedded_adpcm&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the Embedded ADPCM&lt;/title&gt;
&lt;p id=&quot;_25228b34-3bb1-c2f9-5826-9e7173644d77&quot;&gt;The G.727 algorithm is specified in Recommendation ITU-T G.727 &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.727&quot; citeas=&quot;[10]&quot;/&gt; with the block diagram shown in &lt;xref target=&quot;fig-G727&quot;/&gt;, and will not be further described here. Additional information can be found in &lt;eref type=&quot;inline&quot; bibitemid=&quot;ADPCM-Tech-Report&quot; citeas=&quot;[26]&quot;/&gt;, where a thorough comparison is made between different ADPCM schemes, including G.726 and G.727. Details on the linear interface for the G.727 algorithm are found in G.727 Annex A &lt;eref type=&quot;inline&quot; bibitemid=&quot;G727-LinearIO&quot; citeas=&quot;[11]&quot;/&gt;.&lt;/p&gt;

&lt;clause id=&quot;_extension_for_linear_input_and_output_signals_2&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001688</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_itu_t_stl_g_727_implementation'>_itu_t_​stl_g_727_​implementation</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_itu_t_stl_g_727_implementation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;ITU-T STL G.727 Implementation&lt;/title&gt;
&lt;p id=&quot;_5a1c09ea-8584-f347-70ce-0b61231758ea&quot;&gt;The STL implementation of the G.727 algorithm can be found in module &lt;tt&gt;g727.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;g727.h&lt;/tt&gt;.&lt;/p&gt;

&lt;p id=&quot;_506ccf2f-5cec-99c7-e943-c674e5e28fbe&quot;&gt;The problem of storing the state variables was solved by defining a structure containing all the necessary variables, defining a new type called &lt;tt&gt;G727_state&lt;/tt&gt;. As for other STL modules, the use of the state variable allows for parallel processing flows in the same executable program. The internal elements of the state variable &lt;tt&gt;G727_state&lt;/tt&gt; should not be modified by the user, and are not described here.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>001876</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_g_728_the_itu_t_low_delay_celp_algorithm_at_16_kbits'>_g_728_​the_itu_t_​low_delay_​celp_​algorithm_at_16_​kbits</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_g_728_the_itu_t_low_delay_celp_algorithm_at_16_kbits&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;G.728: The ITU-T low-delay CELP algorithm at 16 kbit/s&lt;/title&gt;
&lt;note id=&quot;_e12417a1-c7a8-d610-a721-1df0783c2eae&quot;&gt; &lt;p id=&quot;_58324aa7-339c-dac7-8c6c-bbbbe54ca6ef&quot;&gt;The following description is only applicable to the basic G.728 operating mode, 16 kbit/s, both in floating-point (i.e. G.728 main body &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.728&quot; citeas=&quot;[12]&quot;/&gt;) and in fixed-point implementation (i.e. G.728 Annex G &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.728G&quot; citeas=&quot;[13]&quot;/&gt;). The packet loss concealment for the LD-CELP decoder (G.728 Annex I &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.728I&quot; citeas=&quot;[14]&quot;/&gt;) is also described. The other bitrate extensions (G.728 Annexes H and J) are not part of this description.&lt;/p&gt;
&lt;/note&gt;
</pre></td><td>2</td></tr>
<tr class="severity2">
<td>002647</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_encoder_structures'>_encoder_​structures</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_encoder_structures&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Encoder structures&lt;/title&gt;
&lt;p id=&quot;_9f6950f4-6905-92e6-f8db-57f1bff64656&quot;&gt;In the following, the LD-CELP encoder blocks are described, as illustrated in &lt;xref target=&quot;fig-G728a&quot;/&gt;.&lt;/p&gt;

&lt;clause id=&quot;_lpc_synthesis_filter&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>002837</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_decoder_structures'>_decoder_​structures</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_decoder_structures&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Decoder structures&lt;/title&gt;
&lt;p id=&quot;_1def8da8-9863-f22e-7dc6-c0a8099d98e6&quot;&gt;The decoder structure is found in &lt;xref target=&quot;fig-G728b&quot;/&gt;. The blocks that are identical to ones in the encoder will not be described again. The few blocks unique to the decoder are described in the following.&lt;/p&gt;

&lt;clause id=&quot;_post_filter_and_its_adaptation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>002886</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_itu_t_stl_g_728_implementation'>_itu_t_​stl_g_728_​implementation</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_itu_t_stl_g_728_implementation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;ITU-T STL G.728 Implementation&lt;/title&gt;
&lt;p id=&quot;_9aa1209e-df74-a912-d772-7bd06ebb4b4f&quot;&gt;This implementation of the G.728 algorithm is composed of source files in several directories. The floating-point version of the algorithm can be found in the directory &lt;tt&gt;g728/g728float&lt;/tt&gt;. The fixed-point version is in &lt;tt&gt;g728/g728fixed&lt;/tt&gt;. A third directory, &lt;tt&gt;g728/testvector&lt;/tt&gt;, is designed to hold the test vectors for both versions of the algorithm. The contents of the testvector directory are not part of the STL, but can be obtained from G.728 Appendix I on the ITU-T web site. Similar data structures and interface functions are defined for both the floating-point and fixed-point G.728 implementations. The floating-point interface is discussed first.&lt;/p&gt;

&lt;clause id=&quot;_floating_point_g_728&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003218</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_g_722_the_itu_t_64_56_and_48_kbits_wideband_speech_coding_algorithm'>_g_722_​the_itu_t_64_​56_and_48_​kbits_​wideband_​speech_coding_​algorithm</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_g_722_the_itu_t_64_56_and_48_kbits_wideband_speech_coding_algorithm&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;G.722: The ITU-T 64, 56, and 48 kbit/s wideband speech coding algorithm&lt;/title&gt;
&lt;p id=&quot;_56930317-7e1c-4fce-76d7-a9e69205b0a6&quot;&gt;With the emergence of ISDN networks offering digital connectivity at 64 kbit/s between subscribers, the possibility was given to improve the standard telephone quality by increasing the transmitted bandwidth. A bandwidth of 50-7000 Hz corresponding to a sampling of 16 kHz was chosen because it provides a substantial improvement of the quality for applications where the speech is to be heard through high quality loudspeakers e.g. for audio or video conference services, commentary broadcasting, and high quality handsfree phones.&lt;/p&gt;

&lt;p id=&quot;_77fd665a-0405-6765-f7d1-f26a4af96fee&quot;&gt;An expert group was created in November 1983 whose mandate was to define a standard for 7 kHz speech coding within 64 kbit/s. After many contributions received from several organisations, it has been decided to choose a coder which combined subband filtering and adaptive differential pulse-code modulation algorithms (SB-ADPCM). The final recommendation was produced in March 1986 and approved in July 1986 by the then CCITT SG XVIII as Recommendation ITU-T G.722 &lt;eref type=&quot;inline&quot; bibitemid=&quot;G.722&quot; citeas=&quot;[6]&quot;/&gt;.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003259</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_64_56_and_48_kbits_g_722_algorithm'>_​description_of_the_​64_56_and_​48_kbits_​g_722_​algorithm</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_64_56_and_48_kbits_g_722_algorithm&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the 64, 56, and 48 kbit/s G.722 algorithm&lt;/title&gt;
&lt;p id=&quot;_9b7da30c-f88a-dd0e-c2f0-c7cedfdf8c8a&quot;&gt;In order to improve the transmitted speech quality, the input signal has to be converted after antialiasing filtering by an analog-to-digital (A/D) converter operating at 16 kHz sampling rate and with a resolution of at least 14 uniform PCM bits. Similarly, at the receive side, a digital-to-analog (D/A) converter operating at 16 kHz sampling rate and with a resolution of at least 14 uniform PCM bits should be used. The specifications of the transmission characteristics of the audio parts suited for the G.722 algorithm are described in the Recommendation. Some flexibility of the output bit rate was implemented to allow the opening of an auxiliary data channel within the 64 kbit/s channel.&lt;/p&gt;

&lt;clause id=&quot;G722-descr-encoder&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003263</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#G722-descr-encoder'>G722-descr-encoder</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;G722-descr-encoder&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Functional description of the SB-ADPCM encoder&lt;/title&gt;
&lt;p id=&quot;_9bb236e5-b2a6-f25a-f728-5b7c340c6449&quot;&gt; &lt;xref target=&quot;G722-encoder&quot;/&gt; shows block diagram of the SB-ADPCM encoder which comprises the following main blocks.&lt;/p&gt;

&lt;figure id=&quot;G722-encoder&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003320</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#G722-descr-decoder'>G722-descr-decoder</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;G722-descr-decoder&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Functional description of the SB-ADPCM decoder&lt;/title&gt;
&lt;p id=&quot;_3fc9c8c9-8c8b-6be4-138f-c6d30f52a96a&quot;&gt; &lt;xref target=&quot;G722-decoder&quot;/&gt; shows block diagram of the SB-ADPCM decoder.&lt;/p&gt;

&lt;clause id=&quot;_demultiplexer&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003409</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_itu_t_stl_g_722_implementation'>_itu_t_​stl_g_722_​implementation</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_itu_t_stl_g_722_implementation&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;ITU-T STL G.722 Implementation&lt;/title&gt;
&lt;p id=&quot;_95b51714-c858-d69a-664a-2ad3f67d95ec&quot;&gt;This implementation of the G.722 algorithm is composed of several source files. The interface routines are in file &lt;tt&gt;g722.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;g722.h&lt;/tt&gt;. The original code of the STL G.722 was provided by CNET/France and its user interface was modified to be consistent with the other software modules of the STL. The update to make G.722 tool compliant with G.192 bit stream format and include basic PLC functionality was performed by Ericsson. The basic operators and complexity counters were introduced by France Telecom.&lt;/p&gt;

&lt;p id=&quot;_7b920594-544f-c329-a122-85692e651466&quot;&gt;The problem of storing the state variables was solved by defining a structure called &lt;tt&gt;g722_state&lt;/tt&gt; which containing all the necessary state variables. By means of this approach, several streams may be processed in parallel&lt;fn reference=&quot;22&quot;&gt; &lt;p id=&quot;_bcd1822a-88ba-476c-eff3-b8039242c980&quot;&gt;This feature was not possible with the original code provided by CNET and was added in the modifications of the user interface.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003759</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_rpe_ltp_the_full_rate_gsm_codec'>_rpe_ltp_​the_full_​rate_gsm_​codec</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_rpe_ltp_the_full_rate_gsm_codec&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;RPE-LTP: The full-rate GSM codec&lt;/title&gt;
&lt;p id=&quot;_0540db54-f016-a1c0-5c4e-9d68598fded6&quot;&gt;In 1988, the Groupe Special Mobile of the Conference Europeéne des Postes et Telecommunications (CEPT) approved the first generation of a pan-European digital cellular radio system operating at a net rate of 13 kbit/s&lt;fn reference=&quot;25&quot;&gt; &lt;p id=&quot;_6ec72355-f0b7-acb4-df40-83408db1169e&quot;&gt;The GSM standard developed initially under the responsability of the CEPT was later transferred to the European Standardisation Telecommunications Institute (ETSI), and the acronym GSM had its meaning changed to Global System for Mobile Communications. Currently, the GSM specifications are being maintained by the Third Generation Partnership Project, 3GPP (www.3gpp.org).&lt;/p&gt;
&lt;/fn&gt;. Its speech coding algorithm, the RPE-LTP (Regular Pulse Excitation, Long Term Predictor) was a compromise solution of the two best coders at that stage. The full-rate GSM system started operation in the beginning of 1992 in some European countries and its expansion is expected in a mid-term. This coder, despite not being an ITU-T standard, is relevant for standardization studies when scenarios involving tandeming conditions between the PSTN and the European cellular system need to be studied.&lt;/p&gt;
</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003768</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#principles'>principles</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;principles&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the 13 kbit/s RPE-LTP algorithm&lt;/title&gt;
&lt;p id=&quot;_e28e1da5-5899-da93-d758-ae916aaf76cd&quot;&gt;The RPE-LTP is a frame based coder, encoding 20 ms frames of input data at a time. The encoder converts each 160 sample frame (8 kHz sampling rate, 13 bits uniform PCM format) into a bitstream frame of 260 bits. The decoder uses the 260 bitstream bits to generate a frame of 160 reconstructed speech samples.&lt;/p&gt;

&lt;clause id=&quot;_rpe_ltp_encoder&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>003801</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation_3'>_​implementation_3</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation_3&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_684a0d75-8733-3335-5b25-a5e5121e3842&quot;&gt;This implementation of the RPE-LTP algorithm is composed of several source files. The interface routines are in &lt;tt&gt;rpeltp.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;rpeltp.h&lt;/tt&gt;.&lt;/p&gt;

&lt;p id=&quot;_44f7433e-aac6-ca10-a6fc-0c40ce28ad43&quot;&gt;Originally written to be a device driver in Unix (known as &lt;em&gt;toast&lt;/em&gt;), its interface was adapted to the specifications of the ITU-T STL, and modified to operate correctly in a variety of platforms, like VAX, IBM PC compatibles, and Unix workstations (Sun and HP).&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>004169</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_rate_change_up_and_down_sampling_module'>_rate_​change_up_and_​down_​sampling_​module</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_rate_change_up_and_down_sampling_module&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;RATE-CHANGE: Up- and down-sampling module&lt;/title&gt;
&lt;p id=&quot;_6e1db2a6-8f0e-91d8-d1cb-8c580702b1c1&quot;&gt;In certain applications involving digitized speech, such as subjective evaluation of speech processed by digital algorithms, it may be preferable to use sampling higher than the typical rate used for the algorithms under test. This is desirable because simpler analog filters with less phase distortion can be built. Another advantage is that upper frequency components of the signal are not lost. It also allows for the convenient shaping of the input signal, such as IRS, &lt;asciimath&gt;Delta_(SM)&lt;/asciimath&gt;, and psophometric weightings. Consequently there is a need to adapt the sampling rate of the digitized signal to that of the processing algorithm. For telephony applications, the typical sampling rate is 8000 Hz with a signal bandwidth in general of 300-3400 Hz, and for wideband speech applications, a bandwidth of 50-7000 Hz is desired with sampling rate of 16000 Hz. During the 2005-2008 ITU-T study period, greater audio bandwidth were considered and superwideband and fullband audio codecs were developed. Their typical samplings rates are respectively 32000 Hz with a signal bandwidth of 50-14000 Hz, and 48000 Hz with a signal bandwidth of 20-20000 Hz. Therefore, sampling rates above 8000 Hz and 16000 Hz are desirable, respectively. In several experiments &lt;eref type=&quot;inline&quot; bibitemid=&quot;LDCELP-voitests&quot; citeas=&quot;[70]&quot;/&gt; the sampling rate was 16 kHz. In others (see &lt;eref type=&quot;inline&quot; bibitemid=&quot;ETSI-half&quot; citeas=&quot;[71]&quot;/&gt; and &lt;eref type=&quot;inline&quot; bibitemid=&quot;AC-05-16&quot; citeas=&quot;[72]&quot;/&gt;), 48 kHz and 32 kHz were utilized. Hence the need for a software tool to carry out filtering and sampling rate change. Next, the rate change and spectral weighting routines implemented in the ITU-T STL are presented.&lt;/p&gt;

&lt;clause id=&quot;_description_of_the_algorithm_3&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>004173</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_algorithm_3'>_​description_of_the_​algorithm_​3</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_algorithm_3&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the Algorithm&lt;/title&gt;
&lt;p id=&quot;_8b363961-7556-96ff-302b-7effd2579a21&quot;&gt;Signal processing theory describes the basic arrangement for decimation of signals; first the signal is low-pass filtered to limit its bandwidth in order to avoid aliasing when the rate is lowered and, second, to decimate the samples, i.e., to drop out samples from the input signal, such that the desired output rate is obtained. For example, if a rate reduction from 48 kHz to 8 kHz is desired, a decimation factor of 6:1 is necessary. This is equivalent to say that, after limiting the bandwidth of the digitized speech to 4 kHz, 5 out 6 samples are skipped, or alternatively, only 1 out of 6 samples will be kept (or saved) from the signal.&lt;/p&gt;

&lt;p id=&quot;_b46a17da-4d2f-a248-a6d2-b65db7295ab3&quot;&gt;The up-sampling of signals requires that each of the input samples be followed by a number of zero samples, such that the desired output rate is achieved; after this, an interpolation operation of these zero samples is performed to obtain a continuous-envelope signal. For example, up-sampling data from 8 kHz to 16 kHz requires interleaving each sample of the input signal with a zero sample followed by interpolation of the signal. This interpolation can be carried out by means of a polynomial, which is equivalent to a filtering operation.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>004647</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation_4'>_​implementation_4</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation_4&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_d7ffd82f-ee8a-7e1b-5198-aff171b62f3d&quot;&gt;The rate change algorithm is organized in two modules, FIR and IIR, with prototypes respectively in &lt;tt&gt;firflt.h&lt;/tt&gt; and &lt;tt&gt;iirflt.h&lt;/tt&gt;. It evolved from a version initially developed as part of the ETSI Half-rate GSM codec Host Laboratory exercise &lt;eref type=&quot;inline&quot; bibitemid=&quot;SCD-ETSI&quot; citeas=&quot;[77]&quot;/&gt;. The rate-change functionality was incorporated in the STL92 in two main files, &lt;tt&gt;hqflt.c&lt;/tt&gt; and &lt;tt&gt;pcmflt.c&lt;/tt&gt;. To make these routines more flexible, the following modifications were included:&lt;/p&gt;

&lt;dl id=&quot;_cf816046-406f-549a-2da3-9ff0591129b0&quot;&gt; &lt;dt&gt;FIR&lt;/dt&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>004668</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_fir_module'>_fir_​module</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_fir_module&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;FIR module&lt;/title&gt;
&lt;p id=&quot;_5427a885-97a6-1a1b-10d7-5143bc0f79cc&quot;&gt;The frequency responses of the implemented high-quality low-pass filters are shown in &lt;xref target=&quot;hq-frq-1-2&quot;/&gt; and &lt;xref target=&quot;hq-frq-1-3&quot;/&gt; (for rate-change factors 2 and 3, respectively), while the telephone bandwidth bandpass filter is given in &lt;xref target=&quot;hq-bandpass&quot;/&gt; (only a rate-change factor of 2 is available). The impulse responses of these filters are given in &lt;xref target=&quot;ir-hq-up&quot;/&gt;, &lt;xref target=&quot;ir-hq-down&quot;/&gt;, and &lt;xref target=&quot;ir-bandpass&quot;/&gt;, respectively for the up-sampling filters (factors 2 and 3), for the down-sampling filters (factors 2 and 3), and for the bandpass filter.&lt;/p&gt;

&lt;p id=&quot;_446cf4ca-69df-b03c-70c9-c337b7828d59&quot;&gt;The transmit-side IRS filter has been implemented for the &quot;regular&quot; and modified flavors. The regular transmit-side P.48 IRS filter amplitude responses are shown in &lt;xref target=&quot;tx-reg-irs-frq&quot;/&gt; (the available sampling rates are 8 and 16 kHz). The transmit-side modified IRS filter is available for sampling at 16 kHz and 48 kHz, and their frequency responses are shown in &lt;xref target=&quot;tx-mod-irs-frq&quot;/&gt;. The impulse response of these transmit-side IRS filters are in figures &lt;xref target=&quot;tx-reg-irs-ir&quot;/&gt; and &lt;xref target=&quot;tx-mod-irs-ir&quot;/&gt; for the regular and modified IRS filters, respectively. The receive-side modified IRS filter has also been implemented and the frequency responses for 8 kHz and 16 kHz sampling rate are found in &lt;xref target=&quot;rx-mod-irs-frq&quot;/&gt;. The impulse responses of the receive-side modified IRS filters are shown in &lt;xref target=&quot;rx-mod-irs-ir&quot;/&gt;.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>005132</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_iir_module'>_iir_​module</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_iir_module&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;IIR Module&lt;/title&gt;
&lt;p id=&quot;_1ba50aeb-73dc-db6b-af7d-f3e89334f8c8&quot;&gt;The IIR module contains filters whose main use is for asynchronous filtering. For telephony bandwidth asynchronous filtering, PCM filters are available in both cascade and parallel IIR filter forms. For wideband speech (50—​7000 Hz), 3:1 and 1:3 rate-change factor filters are available. A transmit-side IRS filter for speech sampled at 8 kHz is also available in this module as an example of implementation of an IIR cascade-form filter.&lt;/p&gt;

&lt;p id=&quot;_27992ff3-632d-a782-989e-f5a71efff66b&quot;&gt;The PCM filters have been designed for &lt;em&gt;sampling rates&lt;/em&gt; of 8 and 16 kHz. It should be noted that the G.712 mask is specified in terms of Hz, rather than normalized frequencies. Therefore this applies only to rate conversions of factor 2, i.e., 8 kHz to 16 kHz and 16 kHz to 8 kHz. The frequency responses of the implemented PCM filters are shown in &lt;xref target=&quot;pcm-frq&quot;/&gt;.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>005683</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_eid_error_insertion_device'>_eid_​error_​insertion_device</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_eid_error_insertion_device&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;EID: Error Insertion Device&lt;/title&gt;
&lt;p id=&quot;_bc0285af-a283-1b5c-9f8a-bf29514349eb&quot;&gt;An error insertion device (EID) is used to study the behaviour of codec over digital transmission systems and equipments under error conditions. This requires a model for the transmission channel, and an error generation algorithm. In the most general case, burst or random bit error generators are needed. In other cases, such as when evaluating mobile and wireless systems, random and bursty frame erasures are of importance.&lt;/p&gt;

&lt;p id=&quot;_34c09fe2-8667-5bc3-ec5d-bc38e3f0438d&quot;&gt;The EID module implements the four functionalities: random and bursty bit errors, and random and bursty frame erasures. These four models are based on a linear congruential sequence random number generator, and the bit error insertion and random frame erasure are based on a two-state channel model.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>005811</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation_5'>_​implementation_5</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation_5&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_03862f14-0178-8cfd-eac0-f8458db0b220&quot;&gt;The EID algorithm is written in C-source code can be found in the module &lt;tt&gt;eid.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;eid.h&lt;/tt&gt;. This version evolved from previous C implementations developed by PKI&lt;fn reference=&quot;31&quot;&gt; &lt;p id=&quot;_2eaa4594-1aff-df46-9887-21c235115fb7&quot;&gt;Phillips Communications Industry.&lt;/p&gt;
&lt;/fn&gt;, and was used in the Host Laboratory Sessions of ETSI&apos;s contest for the second generation of the GSM Digital Mobile Radio Systems, and in the Selection Phase of the ITU-T 8 kbit/s speech coder.&lt;/p&gt;
</pre></td><td>2</td></tr>
<tr class="severity2">
<td>006363</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_using_layered_bitstream_error_routine_eid_ev'>_using_​layered_​bitstream_​error_routine_​eid_ev</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_using_layered_bitstream_error_routine_eid_ev&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Using layered bitstream error routine (eid-ev)&lt;/title&gt;
&lt;p id=&quot;_69786e72-cc8e-fa98-2da6-407fd79a8124&quot;&gt;The demonstration program, &lt;tt&gt;eid-ev.c&lt;/tt&gt; demonstrates the use of this module to apply errors in a scalable layered bit stream to simulate a flexible transport channel.&lt;/p&gt;

&lt;p id=&quot;_01b4f946-dc0e-209c-5288-a316c070ed50&quot;&gt;G.192 bitstreams (with sync header), G.192 byte-oriented bitstreams (with sync header) can be processed with this tool. (The byte oriented G.192 input stream is however limited to a maximum frame size of 255). The supported frame error patterns formats for the layers are the G.192 16-bit softbit format (without synchronism header) and the byte-oriented version of the G.192 format (also without synchronism header).&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>006505</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_duo_mnru_the_dual_mode_modulated_noise_reference_unit'>_duo_mnru_​the_dual_​mode_​modulated_noise_​reference_​unit</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_duo_mnru_the_dual_mode_modulated_noise_reference_unit&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Duo-MNRU: The Dual-mode Modulated Noise Reference Unit&lt;/title&gt;
&lt;p id=&quot;_d41befa8-e471-2a1f-498c-c00a59f268e4&quot;&gt;For evaluation of the quality of a system or equipment, it is important to express the quality measure in a unit suitable for comparison with other reference (or well-known) equipments and systems. A common way of representing these figures is by means of relative units, where the quality is expressed by means of a unique figure, in a unidimensional scale.&lt;/p&gt;

&lt;p id=&quot;_b709c1bf-8843-d144-85d2-917dccf6c490&quot;&gt;But it is insuficient to be unidimensional; the scale must be inequivocal, with a universal meaning. As an example, the ACR scale (&lt;em&gt;Absolute Category Rating&lt;/em&gt;, &lt;eref type=&quot;inline&quot; bibitemid=&quot;P.800&quot; citeas=&quot;[19]&quot;/&gt;, Annex B), which is a scale used for listening opinion tests and has five points termed &lt;em&gt;Excellent&lt;/em&gt;, &lt;em&gt;Good&lt;/em&gt;, &lt;em&gt;Fair&lt;/em&gt;, &lt;em&gt;Poor&lt;/em&gt;, and &lt;em&gt;Bad&lt;/em&gt;, is inadequate: besides it shows a continuum of quality points, the meaning of the adjectives are far from universal, varying from language to language, and from person to person. Exchange of information on the performance of these systems and equipments is easier and more consistent with more objective measures. The issue of how the MNRU is to be used as a reference system in subjective tests has been studied in ITU-T Study Group 12, which is described in Recommendation ITU-T P.830 &lt;eref type=&quot;inline&quot; bibitemid=&quot;P.830&quot; citeas=&quot;[21]&quot;/&gt; in its Sections 8.2.2 and 11.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>006758</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation_6'>_​implementation_6</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation_6&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_16641084-dfe1-9e34-b1b3-03766b9ec331&quot;&gt;This implementation of the MNRU algorithm can be found in the module &lt;tt&gt;mnru.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;mnru.h&lt;/tt&gt;. A thorough characterization of this module is presented in &lt;eref type=&quot;inline&quot; bibitemid=&quot;Duo-MNRU&quot; citeas=&quot;[86]&quot;/&gt;. The previous version of the ITU-T STL MNRU was applicable to narrowband signals and evolved from a Fortran implementation which had been used by several laboratories, especially by participants of ETSI&apos;s contest for the second generation of Digital Mobile Radio Systems, and was originally written by experts at CSELT/Italy (sometimes referred as &lt;em&gt;CSELT MNRU&lt;/em&gt;), an implementation fully compliant with the narrowband MNRU specification available in the then-in-force P.81 &lt;eref type=&quot;inline&quot; bibitemid=&quot;Old-P.81&quot; citeas=&quot;[84]&quot;/&gt;.&lt;/p&gt;

&lt;p id=&quot;_d5f24ef7-0376-cd89-f75f-79fe0ef59a14&quot;&gt;With the revision of MNRU specification, several changes had to be made to the STL92 MNRU:&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>007323</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation_7'>_​implementation_7</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation_7&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_29605c00-a84c-254e-fb1b-287c9fb14c23&quot;&gt;This implementation of the speech voltmeter algorithm can be found in the module &lt;tt&gt;sv-p56.c&lt;/tt&gt;, with prototypes in &lt;tt&gt;sv-p56.h&lt;/tt&gt;. This version evolved from a preliminary Fortran implementation provided by Telebrás, Brazil, which was used by several laboratories, in especial by participants of ETSI&apos;s contest for the second generation of Digital Mobile Radio Systems.&lt;/p&gt;

&lt;p id=&quot;_6b68b98a-4935-5ea4-0f7b-36060673fb22&quot;&gt;In Recommendation P.56, there are several undefined issues needed to be resolved for the implementation of this module. Especially, the rate &lt;asciimath&gt;f&lt;/asciimath&gt; used for the averages and the tolerance, or degree of accuracy, &lt;asciimath&gt;delta&lt;/asciimath&gt; to be used for the interpolation of the active level have to be defined. Another undefined parameter is the reference level, or 0 dB reference point &lt;asciimath&gt;r&lt;/asciimath&gt;. The choices of this implementation are shown in the table below:&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>007329</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_503932c6-ce23-a0c1-6ff9-81dbe0c90952'>_503932c6-ce23-a0c1-6ff9-81dbe0c90952</a></code></th>
<td>Table should have title</td><td><pre>&lt;table id=&quot;_503932c6-ce23-a0c1-6ff9-81dbe0c90952&quot; unnumbered=&quot;true&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th colspan=&quot;3&quot; valign=&quot;top&quot; align=&quot;center&quot;&gt;Speech voltmeter parameters&lt;/th&gt;
&lt;/tr&gt; &lt;tr&gt; &lt;th valign=&quot;top&quot; align=&quot;center&quot;&gt;Parameter&lt;/th&gt;
&lt;th valign=&quot;top&quot; align=&quot;center&quot;&gt;Description&lt;/th&gt;
&lt;th valign=&quot;top&quot; align=&quot;center&quot;&gt;Value&lt;/th&gt;
&lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt; &lt;asciimath&gt;f&lt;/asciimath&gt; &lt;/td&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>007713</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_stereo_impulse_response'>_stereo_​impulse_​response</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_stereo_impulse_response&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Stereo impulse response&lt;/title&gt;
&lt;p id=&quot;_7c74a0b9-f6ab-b3db-c4e4-094255dc025f&quot;&gt;In STL 2009, stereo impulse responses were added. These stereo impulse responses were measured in typical meeting rooms with various microphones. The meeting rooms and microphone were selected according to two scenario configurations using two rooms (one per scenario). Pictures of the two rooms are shown in &lt;xref target=&quot;STL09-LargeMeetingRoom&quot;/&gt; and &lt;xref target=&quot;STL09-VideoConferencingRoom&quot;/&gt;. Three types of microphone configurations were considered: MS microphone (Sony ECM-MS907), Binaural (two omnidirectional DPA 4060 inserted into the ears of a dummy head), AB microphone (two omnidirectional DPA 4060 microphones spaced 1 m apart). Moreover, the two scenarios were simulated in an anechoic room, i.e. the stereo impulse responses were also measured in this anechoic room for all the positions and all the microphones except for the binaural microphone. The geometry characteristics of the large (for scenario 1) and small (for scenario 2) rooms are given in the &lt;xref target=&quot;tbl-geom-charac-room&quot;/&gt;. These rooms were acoustically treated in order to limit the reverberation (filled carpet, coustically absorbent wall and ceiling). The acoustic absorption was higher for room of scenario 2 because the room was especially designed for video conferencing.&lt;/p&gt;

&lt;table id=&quot;tbl-geom-charac-room&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>008028</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_algorithm_8'>_​description_of_the_​algorithm_​8</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_algorithm_8&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the algorithm&lt;/title&gt;
&lt;p id=&quot;_d36c3e14-76e8-623f-4f18-842aac9a7083&quot;&gt;An input signal is encoded and decoded by the Codec under Test. The periodogram method is then used to compute the average amplitude spectrum difference between a reference signal (e.g. the input file to the speech codec) and a test signal (e.g. the speech signal after encoding and decoding by a codec).&lt;/p&gt;

&lt;p id=&quot;_dca5c04d-d3d0-ef72-86d6-1c2cf68c2af2&quot;&gt;The input and output signals can be treated on a frame by frame basis, with size power of 2 which defaults to 2048 if unspecified. A Hanning window is applied to each input and output frame. The resulting windowed signals are transformed to the frequency domain using a various number of point Fast Fourier transform. The input and output amplitude spectra are then computed and averaged. This tool produces the average amplitude spectrum in ASCII and also produces a bitmap file.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>008585</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_16_bit_and_32_bit_basic_operators_and_associated_weights'>_​description_of_the_​16_bit_​and_32_bit_​basic_​operators_and_​associated_​weights</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_16_bit_and_32_bit_basic_operators_and_associated_weights&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the 16-bit and 32-bit basic operators and associated weights&lt;/title&gt;
&lt;p id=&quot;_3ae98f2d-1c1f-28a4-5bc4-5a192ab48a4a&quot;&gt;This section describes the different 16-bit and 32-bit basic operators available in the STL, and are organized by complexity (&quot;weights&quot;). The complexity values to be considered (since the publication of the STL2005) are the ones related to the version 2.0 and subsequent versions of the module. When the basic operator did not exist in the previous version of the library (version 1.x), it is highlighted as follows: &lt;asciimath&gt;-&amp;gt;&lt;/asciimath&gt; &lt;smallcap&gt;New in v2.0&lt;/smallcap&gt;. In STL2009, &lt;tt&gt;round()&lt;/tt&gt; operator was renamed as &lt;tt&gt;round_fx()&lt;/tt&gt; and &lt;tt&gt;saturate()&lt;/tt&gt;, function was made unaccessible from applications, because it was an internal procedure.&lt;/p&gt;

&lt;clause id=&quot;_variable_definitions&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>009325</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_basic_operators_for_unsigned_data_types'>_​description_of_the_​basic_​operators_for_​unsigned_​data_types</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_basic_operators_for_unsigned_data_types&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the basic operators for unsigned data types&lt;/title&gt;
&lt;p id=&quot;_ab9052ef-47e8-f74e-2ba2-c010b77f2821&quot;&gt;This section describes the different basic operators for unsigned data types available in the STL, organized by complexity (&quot;weights&quot;).&lt;/p&gt;

&lt;clause id=&quot;_variable_definitions_2&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>009377</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_40_bit_basic_operators_and_associated_weights'>_​description_of_the_​40_bit_​basic_​operators_and_​associated_​weights</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_40_bit_basic_operators_and_associated_weights&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the 40-bit basic operators and associated weights&lt;/title&gt;
&lt;p id=&quot;_d0216f76-cbfa-0e5a-915f-d775fcac2367&quot;&gt;This section describes the different 40-bit basic operators available in the STL, and are organized by complexity (&quot;weights&quot;). The complexity values to be considered (since the publication of the STL2005) are the ones related to the version 2.0 and subsequent versions of the library. These basic operators did not exist in the previous version of the library (version 1.x).&lt;/p&gt;

&lt;p id=&quot;_011bb069-7f05-fa24-0838-1ad05a020c65&quot;&gt;A set of coding guidelines must be followed in order to avoid algorithm complexity miss-evaluation. This section describes also these guidelines.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>009593</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_basic_operators_which_use_complex_data_types'>_​description_of_the_​basic_​operators_​which_use_​complex_data_​types</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_basic_operators_which_use_complex_data_types&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the basic operators which use complex data types&lt;/title&gt;
&lt;p id=&quot;_bb92b339-dd5f-3a8f-526e-212a482de63b&quot;&gt;This section describes the complex basic operators available in the STL, organized by complexity (&quot;weights&quot;).&lt;/p&gt;

&lt;clause id=&quot;_variable_definitions_4&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>009948</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#basop64bitoperators'>basop64bitoperators</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;basop64bitoperators&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the basic operators which use 64-bit registers/accumulators&lt;/title&gt;
&lt;p id=&quot;_0ce46c1a-9229-92dd-2a6c-418e11509dc0&quot;&gt;This section describes the 64-bit basic operators available in the STL, organized by complexity (&quot;weights&quot;).&lt;/p&gt;

&lt;clause id=&quot;_variable_definitions_5&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>010160</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_basic_operators_which_use_32_bit_precision_multiply'>_basic_​operators_​which_use_32_​bit_​precision_​multiply</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_basic_operators_which_use_32_bit_precision_multiply&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Basic operators which use 32-bit precision multiply&lt;/title&gt;
&lt;p id=&quot;_65bf4edb-f571-de59-af9e-68153062612d&quot;&gt;Basic operators in this section are useful for FFT and scaling functions where the result of a 32*16 or 32*32 arithmetic operation is rounded, and saturated to 32-bit value. There is no accumulation of products in these functions. In functions that accumulate products, you should use base operators in Section &lt;xref target=&quot;basop64bitoperators&quot;/&gt;.&lt;/p&gt;

&lt;p id=&quot;_3f172126-ce80-759e-885e-800ca17cd1d2&quot;&gt;All basic operators in this section have a complexity weight of 1.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>010341</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_basic_operators_for_control_operations'>_​description_of_the_​basic_​operators_for_​control_​operations</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_basic_operators_for_control_operations&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the basic operators for control operations&lt;/title&gt;
&lt;p id=&quot;_5be45aad-66c6-32e0-c4c0-66d822be2005&quot;&gt;The following basic operators should be used in the control processing part of the reference code. They are expected to help compilers generate more efficient code for control sections of the reference C code. In addition, they also help in computing a more accurate representation of control code operations in the total WMOPs (weighted millions of operations) of the reference code.&lt;/p&gt;

&lt;p id=&quot;_9b658ff5-38b1-306d-2836-9eb0315a09fc&quot;&gt;All operators in this section have a complexity weight of 1.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>010436</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_description_of_the_control_basic_operators_and_associated_weights'>_​description_of_the_​control_​basic_​operators_and_​associated_​weights</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_description_of_the_control_basic_operators_and_associated_weights&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Description of the control basic operators and associated weights&lt;/title&gt;
&lt;p id=&quot;_faf4c011-e145-847b-1d68-2c1a48a54acc&quot;&gt;This section describes the different control basic operators available in the STL and their associated complexity weights. The complexity values to be considered (since the publication of the STL2005) are the ones related to 2.0 and subsequent versions of the library.&lt;/p&gt;

&lt;p id=&quot;_191c5e8b-6b7e-ba09-9612-26847c1bf6a4&quot;&gt; &lt;strong&gt;A set of coding guidelines must be followed&lt;/strong&gt; in order to avoid algorithm complexity miss-evaluation. This section describes also these guidelines.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>010830</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_data_moves'>_data_​moves</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_data_moves&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Data moves&lt;/title&gt;
&lt;p id=&quot;_8512567c-48db-192a-cce9-2e603cefdc80&quot;&gt;Each data move between two 16-bit or two 32-bit variables, &lt;strong&gt;move16&lt;/strong&gt;() and &lt;strong&gt;move32&lt;/strong&gt;() operators respectively, has a complexity weight of 1.&lt;/p&gt;

&lt;ol id=&quot;_306e9ccd-259e-7bcc-ff0c-fa96b0cbcf98&quot; class=&quot;steps&quot;&gt; &lt;li&gt; &lt;p id=&quot;_d536fe53-6b0b-26e9-bdc1-767e45be418b&quot;&gt;A 16-bit variable cannot be directly moved to a 32-bit or 40-bit variable.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>010845</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_1e8146e0-85f9-40e0-03b4-964dac9c1a9c'>_1e8146e0-85f9-40e0-03b4-964dac9c1a9c</a></code></th>
<td>Table should have title</td><td><pre>&lt;table id=&quot;_1e8146e0-85f9-40e0-03b4-964dac9c1a9c&quot; unnumbered=&quot;true&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;round_fx()&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;round40()&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;L_saturate40()&lt;/td&gt;
&lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;extract_h()&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;Extract40_H()&lt;/td&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>011022</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_00af4ce6-00ca-c931-85f1-a28f2d2042de'>_00af4ce6-00ca-c931-85f1-a28f2d2042de</a></code></th>
<td>Table should have title</td><td><pre>&lt;table id=&quot;_00af4ce6-00ca-c931-85f1-a28f2d2042de&quot; unnumbered=&quot;true&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt; &lt;tt&gt;g722.c&lt;/tt&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;87&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;28&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt; &lt;/tbody&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>011031</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_f6780aa6-b6c1-3163-034d-815bfe0bf223'>_f6780aa6-b6c1-3163-034d-815bfe0bf223</a></code></th>
<td>Table should have title</td><td><pre>&lt;table id=&quot;_f6780aa6-b6c1-3163-034d-815bfe0bf223&quot; unnumbered=&quot;true&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt; &lt;tt&gt;g722.c&lt;/tt&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;87&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;28&lt;/td&gt;
&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt; &lt;tt&gt;funcg722.c&lt;/tt&gt; &lt;/td&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>012636</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_utilities_ugst_utilities'>_​utilities_ugst_​utilities</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_utilities_ugst_utilities&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;UTILITIES: UGST utilities&lt;/title&gt;
&lt;p id=&quot;_0f133d28-95a7-f226-f156-a3f05df699d3&quot;&gt;This module does not relate to any ITU-T Recommendation, but implements several general-purpose routines, that are needed when using other STL modules.&lt;/p&gt;

&lt;p id=&quot;_83cd21b6-aa49-bdc2-ad5f-dcb8c38d12b8&quot;&gt;In the process of implementing the STL modules, it was found that the interfacing between data representations (&lt;tt&gt;float&lt;/tt&gt; and &lt;tt&gt;short&lt;/tt&gt;; &lt;tt&gt;serial&lt;/tt&gt; and &lt;tt&gt;parallel&lt;/tt&gt;) could present problems. Hence, algorithms implementation these functions have been made available in the ITU-T STL. Additionally, a scaling routine for application of gain and loss to speech samples is included.&lt;/p&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>012647</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#_implementation_12'>_​implementation_12</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;clause id=&quot;_implementation_12&quot; inline-header=&quot;false&quot; obligation=&quot;normative&quot;&gt;
&lt;title&gt;Implementation&lt;/title&gt;
&lt;p id=&quot;_1d597a93-2003-4f54-4ca7-4cbc9df76649&quot;&gt;The functions implemented in this module are:&lt;/p&gt;

&lt;dl id=&quot;_f1d80683-8d54-6bb3-7c6c-504326cf7438&quot;&gt; &lt;dt&gt; &lt;tt&gt;scale&lt;/tt&gt; &lt;/dt&gt;</pre></td><td>2</td></tr>
<tr class="severity2">
<td>013204</td><th><code><a href='/__w/mn-samples-itu/mn-samples-itu/_site/documents/STL-manual/en.html#annexA'>annexA</a></code></th>
<td>Hanging paragraph in clause</td><td><pre>&lt;annex id=&quot;annexA&quot; inline-header=&quot;false&quot; obligation=&quot;informative&quot;&gt;
&lt;title&gt;Unsupported tools&lt;/title&gt;
&lt;p id=&quot;_4fb65a62-5ac0-8714-3a33-b9fcc56177db&quot;&gt;This Appendix to the ITU-T Software Tool Library (STL) Manual describes the unsupported tools provided in the ITU-T STL. The tools are named as &quot;unsupported&quot; because they do not follow the initial modularity concept of STL. These tools are provided &quot;as is&quot; and without any warranties or implied suitability to use. However, any feedback on problems with these tools will be welcome and accomodated as possible, as will any improvements made which can be shared and incorporated in the STL.&lt;/p&gt;

&lt;clause id=&quot;_source_code&quot; inline-header=&quot;false&quot; obligation=&quot;informative&quot;&gt;</pre></td><td>2</td></tr>
</tbody></table>
<h2 id="Metanorma_XML_Syntax">Metanorma XML Syntax</h2>
<table border="1">
<thead><th width="5%">Line</th><th width="20%">ID</th>
<th width="30%">Message</th><th width="40%">Context</th><th width="5%">Severity</th></thead>
<tbody>
<tr class="severity2">
<td></td><th><code>XML Line 000010:30</code></th>
<td>definition of "OlAttr" in "include" does not override anything</td><td><pre></pre></td><td>2</td></tr>
</tbody></table>
</body></html>
